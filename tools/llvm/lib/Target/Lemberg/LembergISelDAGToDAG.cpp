//===- LembergISelDAGToDAG.cpp - A dag to dag inst selector for Lemberg ---===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the Lemberg target.
//
//===----------------------------------------------------------------------===//

#include "Lemberg.h"
#include "LembergISelLowering.h"
#include "LembergTargetMachine.h"
#include "LembergRegisterInfo.h"
#include "llvm/DerivedTypes.h"
#include "llvm/Intrinsics.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
/// LembergDAGToDAGISel - Lemberg specific code to select lemberg machine
/// instructions for SelectionDAG operations.
namespace {
  class LembergDAGToDAGISel : public SelectionDAGISel {
  public:
    LembergDAGToDAGISel(LembergTargetMachine &TM, CodeGenOpt::Level OptLevel)
      : SelectionDAGISel(TM, OptLevel) {
	}

    virtual const char *getPassName() const {
      return "Lemberg DAG->DAG Pattern Instruction Selection";
    }

    // Include the pieces autogenerated from the target description.
#include "LembergGenDAGISel.inc"

  private:	  
	  SDNode *Select(SDNode *N);

	  // Complex Pattern
	  bool SelectAddr(SDValue N, SDValue &Base, SDValue &Offset); 

	  inline SDValue getI32Imm(unsigned Imm) {
		  return CurDAG->getTargetConstant(Imm, MVT::i32);
	  }

  };
}  // end anonymous namespace

FunctionPass *llvm::createLembergISelDag(LembergTargetMachine &TM,
										 CodeGenOpt::Level OptLevel) {
  return new LembergDAGToDAGISel(TM, OptLevel);
}

SDNode *LembergDAGToDAGISel::Select(SDNode *N) {
  DebugLoc DL = N->getDebugLoc();
  EVT VT = N->getValueType(0);

  if (N->isMachineOpcode())
    return NULL;   // Already selected.

  return SelectCode(N);
}

/// ComplexPattern used on LembergInstrInfo
/// Used on Lemberg Load/Store instructions
bool LembergDAGToDAGISel::SelectAddr(SDValue Addr, SDValue &Offset, SDValue &Base)
{
  FrameIndexSDNode *FIN = 0;

  // if Address is FI, get the TargetFrameIndex.
  if ((FIN = dyn_cast<FrameIndexSDNode>(Addr))) {
    Base   = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
    Offset = CurDAG->getTargetConstant(0, MVT::i32);
    return true;
  }

  // Operand is a result from an ADD.
  if (Addr.getOpcode() == ISD::ADD) {
    ConstantSDNode *CN = 0;

    if ((FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) &&
        (CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1)))) {

      // Constant positive word offset from frame index
      Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
      Offset = CurDAG->getTargetConstant(CN->getSExtValue(), MVT::i32);
      return true;
    }
  }

  return false;
}
